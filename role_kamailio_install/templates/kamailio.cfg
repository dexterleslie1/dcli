#!KAMAILIO

#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_UAC
#!define WITH_USRLOCDB
#!define WITH_ACCDB
##!define WITH_DEBUG
#!define WITH_NAT
#!define WITH_SERVERNAT
#!define WITH_MULTIDOMAIN
##!define WITH_ANTIFLOOD
##!define WITH_TLS
#!define WITH_WEBSOCKETS
##!define WITH_SINGLEMEDIA
#!define WITH_MUTIMEDIA
#!define WITH_MONITOR


####### Include Local Config If Exists #########

import_file "kamailio-local.cfg"

####### Defined Values #########

# - database URL - used to connect to database server by modules
#!ifdef WITH_MYSQL
#!define DBURL "mysql://DB_USER:DB_PASSWORD@DB_HOST:DB_PORT/DB_NAME"
#!endif
#!ifdef WITH_MULTIDOMAIN
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7
#!define FLT_FS 10
#!define HTTP_TIMEOUT 5000

####### Global Parameters #########
### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR

#!ifdef WITH_DEBUG
debug = 3
log_stderror = no
#!else
debug = 2
log_stderror = no
#!endif
memdbg = 5
memlog = 5
log_facility = LOG_LOCAL0
fork = yes
children = 1
max_while_loops = 10000
async_workers = 4
# uncomment the next line to disable TCP (default on)
#disable_tcp=yes
# uncomment the next line to disable the auto discovery of local aliases
# based on reverse DNS on IPs (default on)
#auto_aliases=no
# add local domain aliases
#alias="INTERNAL_IP_ADDR:SIP_PORT"
# configure interface/port/proto kamailio will bind on
#!ifdef WITH_SERVERNAT
listen = udp:INTERNAL_IP_ADDR:SIP_PORT advertise EXTERNAL_IP_ADDR:SIP_PORT
#isten=udp:127.0.0.1:SIP_PORT
#listen=tcp:127.0.0.1:SIP_PORT
#!ifdef WITH_WEBSOCKETS
listen = tls:INTERNAL_IP_ADDR:WSS_PORT advertise EXTERNAL_IP_ADDR:WSS_PORT
#!endif
#!else
listen = udp:INTERNAL_IP_ADDR:SIP_PORT
#listen=udp:127.0.0.1:SIP_PORT
#listen=tcp:127.0.0.1:SIP_PORT
#!ifdef WITH_WEBSOCKETS
listen = tls:INTERNAL_IP_ADDR:WSS_PORT
#!endif
#!endif
port = SIP_PORT
#!ifdef WITH_TLS
enable_tls = yes
#!ifdef WITH_SERVERNAT
listen = tls:INTERNAL_IP_ADDR:SIPS_PORT advertise EXTERNAL_FQDN:SIPS_PORT
#!else
listen = tls:INTERNAL_IP_ADDR:SIPS_PORT advertise EXTERNAL_FQDN:SIPS_PORT
#!endif

tcp_accept_no_cl = yes
tcp_rd_buf_size = 16384
#!endif
# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime = 3605
# this parameter controls the Server” header in any locally generated message.
# we disable it by default
server_signature = no

####### Custom Parameters #########

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
mpath = "/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!else
mpath = "/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "path.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "xhttp.so"
loadmodule "jsonrpcs.so"
loadmodule "http_async_client.so"
loadmodule "cfgutils.so"
loadmodule "async.so"
loadmodule "http_client.so"
# must be loaded after dmq
loadmodule "htable.so"
loadmodule "dialog.so"
loadmodule "rtimer.so"
loadmodule "sqlops.so"
#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!ifdef WITH_UAC
loadmodule "uac.so"
#!endif
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_WEBSOCKETS
loadmodule "websocket.so"
#!endif

#!ifdef WITH_HOMER
loadmodule "siptrace.so"
#!endif



# ----------------- setting module-specific parameters ---------------

# ---- htable global params ----
modparam("htable", "db_url", DBURL)

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam(
        "jsonrpcs",
        "fifo_name",
        "/var/run/kamailio/kamailio_rpc.fifo"
)
modparam("jsonrpcs", "transport", 3)
# ----- ctl params -----
modparam(
        "ctl",
        "binrpc",
        "unix:/var/run/kamailio/kamailio_ctl"
)

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 25sec
modparam("tm", "fr_timer", 25000)
modparam("tm", "max_inv_lifetime", 180000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "auto_inv_100", 0)
#modparam("tm", "auto_inv_100_reason", "Trying")
modparam("tm", "fr_timer", 120000)
# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# append from tag to the RR (no need for this script)
#modparam("rr", "append_fromtag", 0)
#modparam("rr", "enable_double_rr", 2)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
#modparam("acc", "db_insert_mode", 2)
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdrs_table", "acc_cdrs")
modparam(
        "acc",
        "cdr_extra",
        "caller=$dlg_var(cdr_caller);callee=$dlg_var(cdr_callee);trans_to=$dlg_var(cdr_trans_to);"
        "src_user=$dlg_var(cdr_src_user);dest_user=$dlg_var(cdr_dest_user);ctype=$dlg_var(cdr_ctype);"
        "provid_in=$dlg_var(cdr_provid_in);provid_out=$dlg_var(cdr_provid_out);callid=$ci;sipcode=$rs;reason=$rr;"
        "scr_domain=$fd;dest_domain=$dlg_var(cdr_dest_domain)"
)
modparam("acc", "cdr_extra_nullable", 1)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam(
        "acc",
        "log_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd"
)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)

/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam(
        "acc",
        "db_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd"
)
modparam("acc", "cdr_start_on_confirmed", 1)
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 3)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "handle_lost_tcp", 1)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "use_domain", MULTIDOMAIN)

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 0)
#!endif

#!ifdef WITH_NAT

# ----- rtpengine params -----
modparam("rtpengine", "db_url", DBURL)
modparam("rtpengine", "read_sdp_pv", "$var(sdp)")
#!ifdef WITH_SINGLEMEDIA
modparam("rtpengine", "setid_avp", "$avp(setid)")
#!endif
#http_client
modparam("http_client", "connection_timeout", 5)
modparam("http_client", "authmethod", 1)
modparam(
        "http_client",
        "httpcon",
        "restApi=>http://HTTP_USERNAME:HTTP_PASSWORD@HTTP_SERVER:HTTP_PORT"
)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam(
        "nathelper",
        "sipping_from",
        "sip:pinger@EXTERNAL_IP_ADDR:SIP_PORT"
)

# params needed for NAT traversal in other modules
modparam(
        "nathelper|registrar",
        "received_avp",
        "$avp(RECEIVED)"
)
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
modparam("tls", "config", "//etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam(
        "htable",
        "htable",
        "ipban=>size=8;autoexpire=300;dmqreplicate=1;"
)
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

#!ifdef WITH_UAC
# ----- uac params -----
modparam("uac", "restore_mode", "none")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 120)
modparam("uac", "reg_active", 0)
modparam("uac", "reg_keep_callid", 1)
modparam("uac", "reg_gc_interval", 30)
modparam("uac", "credential", "username:domain:password")
modparam("uac", "auth_realm_avp", "$avp(arealm)")
modparam("uac", "auth_username_avp", "$avp(auser)")
modparam("uac", "auth_password_avp", "$avp(apass)")
modparam("uac","reg_contact_addr","EXTERNAL_IP_ADDR:SIP_PORT")
#!endif

# ----- rtimer params -----
modparam(
        "rtimer",
        "timer",
        "name=cdr;interval=300;mode=1;"
)
modparam("rtimer", "exec", "timer=cdr;route=CDRS")

# ----- sqlops params -----
modparam(
        "sqlops",
        "sqlcon",
        "ca=>mysql://DB_USER:DB_PASSWORD@DB_HOST:DB_PORT/DB_NAME"
)
modparam("sqlops", "sqlres", "ra")

# ----- dialog params -----
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_flag", 1)
modparam("dialog", "hash_size", 4096)
modparam("dialog", "detect_spirals", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "timeout_noreset", 1)
modparam("dialog", "send_bye", 0)
modparam("dialog", "timeout_avp", "$avp(timeout)")
modparam("dialog", "ka_interval", 30)
modparam("dialog", "ka_timer", 10)


# ----- http_async_client params -----
modparam("http_async_client", "workers", 1)
modparam(
        "http_async_client",
        "connection_timeout",
        HTTP_TIMEOUT
)
modparam("http_async_client", "hash_size", 2048)

#!ifdef WITH_DEBUG
modparam("http_async_client", "curl_verbose", 1)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif



#!ifdef WITH_HOMER
# check IP and port of your capture node
modparam("siptrace", "duplicate_uri", "sip:HOMER_SERVER:HOMER_PORT")
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_mode", 1)
modparam("siptrace", "trace_flag", 22)
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "hep_version", 3)
modparam("siptrace", "hep_capture_id", 269488144)
#!endif

####### Routing Logic ########

request_route {

        route(REQINIT);
        if (is_method("INVITE")) {
                route(CHECKVALID);
        }




#!ifdef WITH_HOMER
        sip_trace();
        setflag(22);
#!endif
        # NAT detection
        route(NATDETECT);

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                         route(RELAY);
                }
                exit;
        }
        # handle retransmissions
        if (!is_method("ACK")) {
                if (t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }
        # handle requests within SIP dialogs
        route(WITHINDLG);

        # authentication
        route(AUTH);
        # account only INVITEs
        if (is_method("INVITE")) {
                setflag(FLT_ACC);
                # do accounting
        }
        route(PRESENCE);
        route(REGISTRAR);
        if ($rU == $null) {
                # request with no Username in RURI
                sl_send_reply("484", "Address Incomplete");
                exit;
        }
        if (is_method("INVITE")) {
               sl_send_reply("100", "Trying");
#!ifdef WITH_HTTP
                route(HTTP_REQ);
#!else
                $avp(maxsec) = 864000;
                route(MAKECALL);
#!endif
        }
}

# Wrapper for relaying requests
route[RELAY] {
        # enable additional event routes for forwarded requests
        # - serial forking, RTP relaying handling, a.s.o.
        if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                 if (!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
        }
        if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
                if (!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
        }
        if (is_method("INVITE")) {
                if (!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
        }
        if (!t_relay()) {
                sl_reply_error();
        }
        exit;
}

# Per SIP request initial checks
route[REQINIT] {
        # no connect for sending replies
        set_reply_no_connect();
#!ifdef WITH_ANTIFLOOD
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
        if (src_ip != myself) {
                if ($sht(ipban=>$si) != $null) {
                        # ip is already blocked
                        xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
                        exit;
                }
                if (!pike_check_req()) {
                        #xlog("L_INFO","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
                        $sht(ipban=>$si) = 1;
                        exit;
		}
        }
#!endif
        if ($ua =~ "friendly-scanner|sipcli|sipvicious|VaxSIPUserAgent") {
                 # silent drop for scanners - uncomment next line if want to reply
                 # sl_send_reply("200", "OK");
                 exit;
        }
        if (!mf_process_maxfwd_header("10")) {
                sl_send_reply("483", "Too Many Hops");
                exit;
        }
        if (is_method("OPTIONS") && uri == myself && $rU == $null) {
                sl_send_reply("200", "Keepalive");
                exit;
        }
        if (!sanity_check("17895", "7")) {
                xlog("Malformed SIP request from $si:$sp\n");
                exit;
        }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
        if (!has_totag()) return;


        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
                route(DLGURI);
                if (is_method("BYE")) {
                        setflag(FLT_ACC);# do accounting ...
                        setflag(FLT_ACCFAILED); # ... even if the transaction fails
                        sl_send_reply("200","OK"); #新加，不确定
                }else if (is_method("ACK")) {
                                # ACK is forwarded statelessly
                                route(NATMANAGE);
                }else if (is_method("NOTIFY")) {
                                # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                                record_route();
                }
                route(RELAY);
                exit;
        }
        if (is_method("SUBSCRIBE") && uri == myself) {
                # in-dialog subscribe requests
                route(PRESENCE);
                exit;
        }
        if (is_method("ACK")) {
                if (t_check_trans()) {
                        # no loose-route, but stateful ACK;
                        # must be an ACK after a 487
                        # or e.g. 404 from upstream server
                        route(RELAY);
                        exit;
                }else {
                        # ACK without matching transaction ... ignore and discard
                        exit;
                }
        }
        sl_send_reply("404", "Not here");
        exit;
}

# Handle SIP registrations
route[REGISTRAR] {
        if (!is_method("REGISTER")) return;
        if (isflagset(FLT_NATS)) {
                setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
                # do SIP NAT pinging
                setbflag(FLB_NATSIPPING);
#!endif
        }
        if (!save("location")) {
                sl_reply_error();
        }
#!ifdef WITH_HTTP
        route(INVITECONTINUE);
#!endif
        exit;
}

# User location service
route[LOCATION] {
        $avp(oexten) = $rU;
        if (!lookup("location")) {
                $var(rc) = $rc;
                t_newtran();
                switch ($var(rc)) {
                        case -1:
                        case -3:
                                send_reply("404", "Not Found");
                                exit;
                        case -2:
                                send_reply("405", "Method Not Allowed");
                                exit;
                }
        }

        # when routing via usrloc, log the missed calls also
        if (is_method("INVITE")) {
                setflag(FLT_ACCMISSED);
        }
        route(RELAY);
        exit;
}

# Presence server processing
route[PRESENCE] {
        if (!is_method("PUBLISH|SUBSCRIBE")) return;
        # if presence enabled, this part will not be executed
        if (is_method("PUBLISH") || $rU == $null) {
                sl_send_reply("404", "Not here");
                exit;
        }
        return;
}

# IP authorization and user authentication
route[AUTH] {
#!ifdef WITH_AUTH
#!ifdef WITH_IPAUTH
        if ((!is_method("REGISTER")) && allow_source_address()) {
                # source IP allowed
                return;
        }
#!endif
        if (is_method("REGISTER") || from_uri == myself) {
                if (!reg_fetch_contacts("location", "$fu", "caller"))
                        route(REG_PRE_CHECK);

                 # authenticate requests
                 if (!auth_check("$fd", "subscriber", "1")) {
                         auth_challenge("$fd", "0");
                         exit;
                }

                # user authenticated - remove auth header
                if (!is_method("REGISTER|PUBLISH")) consume_credentials();
        }

        # if caller is not local subscriber, then check if it calls
        # a local destination, otherwise deny, not an open relay here
        if (from_uri != myself && uri != myself) {
                #drop;
                sl_send_reply("403", "Not relaying");
                exit;
        }
#!else
        # authentication not enabled - do not relay at all to foreign networks
        if (uri != myself) {
                sl_send_reply("403", "Not relaying");
                exit;
        }
#!endif
        return;
}

# Caller NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
        force_rport();
        if(nat_uac_test("27")) {
                if (is_method("REGISTER")) {
                        fix_nated_register();
                }else {
                        if (is_first_hop()) {
                                set_contact_alias();
                        }
                }
                setflag(FLT_NATS);
        }

#!endif
        return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
        route(CUST_NAT_MISC);
#!ifdef WITH_NAT
        if (is_request()) {
                if (has_totag()) {
                        if (check_route_param("nat=yes")) {
                                setbflag(FLB_NATB);
                        }
                }
        }
        if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;
#!ifdef WITH_SINGLEMEDIA
        route(RTPMANA);
#!endif
#!ifdef WITH_MUTIMEDIA
        if(is_method("UPDATE")){
                route(RTPMANA);
        }
#!endif

        if (is_request()) {
                if ( has_totag()) {
                        if (t_is_branch_route()) {
                                add_rr_param(";nat=yes");
                        }
                }
        }
        if (is_reply()) {
                if (isbflagset(FLB_NATB)) {
                        if (is_first_hop()) set_contact_alias();
                }
        }
        if (isbflagset(FLB_NATB)) {

                # no connect message in a dialog involving NAT traversal
                if (is_request()) {
                        if (has_totag()) {
                                set_forward_no_connect();
                        }
                }
        }
#!endif
        return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
        if (!isdsturiset()) {
                handle_ruri_alias();
        }
#!endif
        return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
        xdbg("new branch [$T_branch_idx] to $ru\n");
        route(ADD_ROUTE);
        route(NATMANAGE);
}

# Manage incoming replies
reply_route {
        if (!sanity_check("17604", "6")) {
                xlog("Malformed SIP response from $si:$sp\n");
                drop;
        }
}

# Manage incoming replies in transaction context
onreply_route[MANAGE_REPLY] {
        xdbg("incoming reply\n");
        if (status =~ "[12][0-9][0-9]") {
                route(NATMANAGE);
        }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
        route(NATMANAGE);
        if (t_is_canceled()) {
                exit;
        }
}

event_route[xhttp:request] {
        if ($hu =~ "^/api/kamailio" && dst_ip==127.0.0.1) {
		jsonrpc_dispatch();
	}
#!ifdef WITH_WEBSOCKETS
	else if ($Rp == WSS_PORT ) {
		if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
			if (ws_handle_handshake()) {
				exit;
			}
		}
        }else {
		xhttp_reply("403", "Forbidden", "text/html",
			"<html><body>Will only communicate on the local interface or WebSocket Port WSS_PORT</body></html>");
		exit;
        }
#!endif
        return;
}

#out call
route[OUT_TO_GATEWAY] {
        $var(gwid) = $avp(gwid);
        $var(host) = '';
        if (sql_query("ca", "call ProviderInfo($var(gwid))", "ra") == 1) {
                if ($dbr(ra=>rows) > 0) {
                        $var(host) = $dbr(ra=>[0,0]);# var(host)会自动加上端口号
                        $avp(auser) = $dbr(ra=>[0,1]);
                        $avp(apass) = $dbr(ra=>[0,2]);
                }
        }
        sql_result_free("ra");
        if ($var(host) == '') {
                sl_send_reply("503", "网关参数不正确");
                exit;
        }else {
                if (is_present_hf("Remote-Party-ID")) remove_hf("Remote-Party-ID");
                $var(From) = $_s(sip:$avp(user)@$var(host));
                $var(TO) = $_s(sip:$rU@$var(host));
                uac_replace_from($avp(user),$var(From));
                uac_replace_to($rU, $var(TO));
                $ru = $var(TO);
                t_on_reply("ONCARRIER");
                t_on_failure("TRUNKAUTH");
        }
        route(RELAY);
}

route[MAKECALL] {
        if (is_method("INVITE")) {
                $var(state) = 0;
                $var(gwid) = 0;
                $var(dest) = "";
                $var(reason) = "";
                $var(canWakeup) = 0;
#!ifdef ALERT
                xlog("L_INFO","*** Call GetCallStatus('$fU','$rU','$ci') ");
#!endif
                if (sql_query("ca","Call GetCallStatus('$fU','$rU','$ci')","ra") == 1) {
                        $var(state) = $(dbr(ra=>[0,0]){s.int});
                        $var(dest) = $dbr(ra=>[0,1]);
                        $var(gwid) = $(dbr(ra=>[0,2]){s.int});
                        $var(reason) = $dbr(ra=>[0,3]);
                        #$var(canWakeup) = $(dbr(ra=>[0,4]){s.int});

                }
                sql_result_free("ra");
                if (($var(state) == 567)) {
#!ifdef ALERT
                        if ($var(state) == 0) xlog("L_INFO","***重复提交:$fU=>$rU ******Callid:[$ci]");
#!endif
                        drop;
                        exit;
                }else if ($var(state) >= 400) {
                                sl_send_reply("$var(state)", "$var(reason)");
                                exit;
                }
                if ($var(gwid) == 0) {
                        $var(user) = $_s(sip:$var(dest)@$RAi);
#!ifdef ALERT
                        xlog("L_INFO", "***呼叫本地用户：[$var(user)]****");
#!endif
/*
                        $var(count) = 3;
                        $var(found) = registered("location", "$var(user)");
                        while(($var(found)<0) && ($var(count)>0)){
                                sleep(1);
                                $var(found) = registered("location", "$var(user)");
                                $var(count) = $var(count) -1;
                        }
                        if($var(found)){
                                route(INCOMING);
                                exit;
                        }
*/
                       if (registered("location", "$var(user)")){
                                route(INCOMING);
                                exit;
                        }
                        if ($var(canWakeup)==1) {
#!ifdef WITH_HTTP
                                t_newtran();
                                $var(caller) = $fU;
                                if (starts_with($var(caller), "+")) {
                                        $var(caller) = "%2B" + $(var(caller){s.strip, 1});
                                }
                                $var(callee) = $var(dest);
                                $http_req(authmethod) = 1;
                                $http_req(username) = "HTTP_USERNAME";
                                $http_req(password) = "HTTP_PASSWORD";
                                $var(param) = $_s(caller=$var(caller)&callee=$var(dest)&callid=$ci);
                                $http_req(body) = $var(param);
#!ifdef ALERT
                                $var(url) = HTTP_WAKEUP_URL;
                                $var(url) = $_s($var(url)?$var(param));
                                xlog("L_INFO","***唤醒本地用户[$var(dest)],$var(url)");
#!endif
                                http_async_query(HTTP_WAKEUP_URL, "WAKEUP_REPL");
#!else
                                sl_send_reply("503", "E#用户无法接通");//没有定义http;
#!endif
                                exit;
                        }else{

                                 sql_query_async("ca", "call NoDlgCdr('$ci','$fd', NULL,408)");
                                 sl_send_reply("408", "E#对方不在线");//安卓无法唤醒
                                 exit;
                        }

                }
                route(INCOMING);
        } #end of is_method
}

route[INCOMING] {
#!ifndef WITH_HTTP
        t_newtran();
#!endif
        if (is_present_hf("P-Asserted-Identity")) remove_hf("P-Asserted-Identity");
        if (is_present_hf("Diversion")) remove_hf("Diversion");
        if (is_method("INVITE")) {
                $var(state) = 0;
                $var(gwid) = 0;
                $var(reason) = "";
#!ifdef ALERT
                xlog("L_INFO","***设置呼叫参数：Call ExCallInfo('$ci') **********");
#!endif
                if (sql_query("ca", "Call ExCallInfo('$ci')", "ra") == 1) {
                        $var(state) = $(dbr(ra=>[0,0]){s.int});
                        $var(i) = $(dbr(ra=>cols)) -2;
                        $var(reason) = $dbr(ra=>[0,$var(i)]);
                        if ($var(state) < 400) {
                                $rU = $dbr(ra=>[0,3]);
                                $var(user) = "";
                                $var(calleename) = $dbr(ra=>[0,8]);#8 2021-06-30增加
                                if ($(dbr(ra=>[0,4]){s.int}) > 0) {
                                        $var(user) = $dbr(ra=>[0,2]);
                                        $avp(user) = $var(user);
                                }else {
                                        $var(user) = $dbr(ra=>[0,1]);
                                }
                                if (($var(state) == 1) || ($var(state) == 3)) {

                                        $var(tmp) = $_s(@$RAi);
                                        if($RAp != 5060) $var(tmp) = $_s(@$RAi:$RAp);
                                        uac_replace_from($dbr(ra=>[0,2]),"sip:" + $var(user) + $var(tmp));
                                        uac_replace_to($var(calleename), $_s(sip:$rU$var(tmp)));
                                        $ru = "sip:" + $rU + $var(tmp);
                                }
                                $var(gwid) = $(dbr(ra=>[0,4]){s.int});

                                #话单处理
                                $dlg_var(cdr_caller) = $dbr(ra=>[0,7]);#7
                                $dlg_var(cdr_callee) = $var(calleename);
                                $dlg_var(cdr_trans_to) = $dbr(ra=>[0,9]);#9
                                $dlg_var(cdr_src_user) = $dbr(ra=>[0,10]);#10
                                $dlg_var(cdr_dest_user) = $dbr(ra=>[0,11]);#11
                                # $dlg_var(cdr_ctype) = $(dbr(ra=>[0,12]){s.int});#12
                                $var(cl) = $(dbr(ra=>[0,12]){s.int});
                                $dlg_var(cdr_ctype) = $var(cl);#12
                                if ($var(cl) == 4) {
                                        sl_send_reply("181", "Refer...");
                                }
                                $dlg_var(cdr_provid_in) = $(dbr(ra=>[0,13]){s.int});#13
                                $dlg_var(cdr_provid_out) = $(dbr(ra=>[0,14]){s.int});#14
                                if ($dbr(ra=>[0,15]) != $null) {
                                        $dlg_var(cdr_dest_domain) = $dbr(ra=>[0,15]);
                                }else {
                                        $dlg_var(cdr_dest_domain) = $RAi;
                                }
                                $dlg_var(cdr_scr_domain) = $fd;
                                $dlg_var(cdr_callid) = $ci;
                                $dlg_var(starttime) = $TV(Sn);
#!ifdef WITH_MUTIMEDIA
                                $dlg_var(rtp1) = $dbr(ra=>[0,17]);
                                $dlg_var(rtp2) = $dbr(ra=>[0,18]);
#!endif
                        }
                        sql_result_free("ra");

#!ifdef WITH_MONITOR
                        dlg_set_property("ka-src");#监视通话
                        dlg_set_property("ka-dst");
                        dlg_set_property("timeout-noreset");
#!endif
#!ifdef WITH_MUTIMEDIA
                         route(RTPMANA);
#!endif
                        if (($var(state) == 3) || ($var(state) == 1)) {
                                t_on_reply("ONLOCAL");
                                route(LOCATION);

                        }else {
                                $avp(gwid) = $var(gwid);
                                route(OUT_TO_GATEWAY);
                        }
                }
        }
}

route[HTTP_REQ] {
        $var(caller) = $(fU{s.escape.param});
        $var(callee) = $(rU{s.escape.param});
        $var(varHttpParameters) = $_s({"caller":"$var(caller)","callee":"$var(callee)"});
        $var(varHttpCode) = http_connect(
                "restApi",
                HTTP_VALIDATE_URL,
                "application/json",
                "$var(varHttpParameters)",
                "$var(varHttpResult)");
        if ($var(varHttpCode) == 200) {
                $var(s) = $(var(varHttpResult){s.trim});
#!ifdef ALERT
                xlog("L_INFO", "***http响应内容:[$var(s)]** $rm ***");
#!endif
                if (starts_with($var(s), "<") || starts_with($var(s), "{")) {
                        sl_send_reply("503", "E#Web Server内部错误,联系客服人员.");
                        exit;
                }

                if (starts_with($var(s), "a")) {

                        #a[590]您号码月租已过期，被限制呼出
                        $var(x) = $(var(s){s.substr, 2, 3});
                        $var(s) = $(var(s){s.substr, 6, 0});
                        sl_send_reply("$var(x)", "$var(s)");
                        exit;
                }else if ($(var(s){s.numeric}) > 0) {
                        $var(s) = $(var(s){s.numeric});
                        $avp(maxsec) = $(var(s){s.int});
                        #$avp(maxsec) = 7500;
                        $avp(timeout)=$avp(maxsec);
                        $dlg_ctx(timeout_route) = "ONTIMEOUT";
                        route(MAKECALL);
                }else {
                        sl_send_reply("503", "E#Web Server内容格式错误");
                        exit;
                }
        }else {
                sl_send_reply("503", "E#Web Server错误");
#!ifdef ALERT
                xlog("L_INFO","失败调用HTTP_VALIDATE_URL接口，参数$var(varHttpParameters)，服务器返回错误码：$var(varHttpCode)，原因：$curlerror(error)");
#!endif
                exit;
        }

        return;
}

route[WAKEUP_REPL] {
        if ($http_ok) {
                sl_send_reply("180", "Ringing");#应为182
                t_on_failure("LOCALFAILURE");
                if (t_suspend()) {
                        sql_query_async("ca", "call SaveTrascation('$ci',$T(id_index),$T(id_label))");
                }
        }else {
#!ifdef ALERT
                $var(s) = HTTP_TIMEOUT;
                xlog("L_INFO", "****Http错误:经过$var(s)ms无返回。");
#!endif
                sl_send_reply("503", "E#Web Server无响应,联系客服人员.");
        }
        exit;
}

event_route[usrloc:contact-expired] {
#!ifdef ALERT
        xlog("L_INFO", "***用户[$ulc(exp=>aor)]掉线。\n");
#!else
        ;   #分号必须
#!endif
}

failure_route[TRUNKAUTH] {
        if (t_is_canceled()) {
                exit;
        }
        if (t_check_status("401|407")) {
                uac_auth();
                route(RELAY);
        }
}

route[REG_PRE_CHECK] {
        $var(cnt) = 0;
#!ifdef ALERT
        xlog("L_INFO","****Call RegCheck('$fU')   鉴权用户:[$au]");
#!endif
        if (sql_query("ca", "Call RegCheck('$fU')", "ra") == 1) {
                $var(cnt) = $(dbr(ra=>[0,0]){s.int});
        }
        sql_result_free("ra");
        if ($var(cnt) == 0) {
                drop;
                exit;
        }
}

route[CHECKVALID] {
        if ($ua =~ "friendly-scanner|sipcli|sipvicious|VaxSIPUserAgent|admin") {
                drop;
                exit;
        }
        if ($au != $null) return;

        #SQL注入攻击

        $var(partten) = "^[+,0-9][0-9]*$";
        $var(allow) = $fU =~ $var(partten);
        if (is_method("INVITE") &&!$var(allow)) {
                        drop;
                        exit;
                }

        #注册攻击和呼叫攻击

        /*
         $var(cnt) = 0;
        if (sql_query("ca", "Call CheckValid('$fU','$rU')", "ra")==1) {
                $var(cnt)= $(dbr(ra=>[0,0]){s.int});
        }
        sql_result_free("ra");
        if ($var(cnt)==0){
                drop;
                exit;
        }
        */
 }

event_route[dialog:start] {
#!ifdef ALERT
        xlog("L_INFO", "***对话开始...$dlg(toroute)");
#!else
        ;   #分号必须
#!endif
}

event_route[dialog:end] {
#!ifdef ALERT
        xlog("L_INFO", "***对话结束...");
#!else
        ;   #分号必须
#!endif

}

event_route[htable:mod-init] {
        $sht(a=>x) = 1;
}
route[INVITECONTINUE] {
        $var(idx) = 0;
        $var(lab) = 0;
        if (sql_query("ca", "call LocateInvite('$fU')", "ra") == 1) {
                $var(idx) = $(dbr(ra=>[0,0]){s.int});
                $var(lab) = $(dbr(ra=>[0,1]){s.int});
        }
        sql_result_free("ra");
        if ($var(idx) > 0 && $var(lab) > 0) {
#!ifdef ALERT
                xlog("L_INFO", "***[$fU]被唤醒,进入Incoming流程");
#!endif
                t_continue("$var(idx)", "$var(lab)", "INCOMING");
        }
        exit;
}

onreply_route[ONLOCAL] {
        if (t_check_status("200") && has_body("application/sdp")) {
               $dlg_var(starttime) = $TV(Sn);
#!ifdef ALERT
                xlog("L_INFO", "***通话限制:[$avp(timeout)]秒.");
#!else
                ;   #分号必须
#!endif
        }
        route(NATMANAGE);
        if(t_check_status("200|180|183")){
                # 2021-06-30 添加 向主叫方显示被叫号码。
                $var(num_name) = $_s("$dlg_var(cdr_callee)" <$dlg(to_uri)>;party=calling;privacy=off;screen=no);
                append_hf("Remote-Party-ID: $var(num_name)\r\n");
        }
#!ifdef WITH_MUTIMEDIA
        route(RTPMANA);
#!endif
}

onreply_route[ONCARRIER] {
        if (t_check_status("200") && has_body("application/sdp")) {
                $dlg_var(starttime) = $TV(Sn);
#!ifdef ALERT
                xlog("L_INFO", "***通话限制:[$avp(timeout)]秒.");
#!else

                ;   #分号必须
#!endif
        }

        if (t_check_status("183")){
                remove_hf("Content-Type");
                change_reply_status(180, "Ringing");
        }
        route(NATMANAGE);
#!ifdef WITH_MUTIMEDIA
        route(RTPMANA);
#!endif
}

route[ONTIMEOUT] {
        $var(cdr_trans_to) = $dlg_var(cdr_trans_to);
        if ($dlg_var(cdr_trans_to) == $null) {
                $var(cdr_trans_to) = "NULL";
        }
        $var(duration) = $_s($TV(Sn) - $dlg_var(starttime));
#!ifdef ALERT
        xlog("L_INFO","***欠费话单: call AddNoCreditCdr('$dlg_var(cdr_callid)',$var(duration),'$dlg_var(cdr_caller)','$dlg_var(cdr_callee)','$var(cdr_trans_to)',$dlg_var(cdr_ctype),$dlg_var(cdr_provid_in),$dlg_var(cdr_provid_out))");
#!endif
        sql_query_async("ca", "call AddNoCreditCdr('$dlg_var(cdr_callid)',$var(duration),'$dlg_var(cdr_caller)','$dlg_var(cdr_callee)','$var(cdr_trans_to)',$dlg_var(cdr_ctype),$dlg_var(cdr_provid_in),$dlg_var(cdr_provid_out))");
        dlg_bye("all");

}

#!ifdef WITH_HOMER
event_route[siptrace:msg] {
    if(is_method("OPTIONS")) {
        drop();
    }
}
#!endif

route[CUST_NAT_MISC]{
        if (is_present_hf("User-Agent")) subst_hf("User-Agent", "/.*/KAMAILIONAME/", "f");
        if (is_present_hf("Server")) subst_hf("Server", "/.*/KAMAILIONAME/", "f");
        if(nat_uac_test(1)&&(from_uri==myself)){
                fix_nated_contact();
        }
        return;
}

route[ADD_ROUTE]{

        if ( (!has_totag()) && is_method("INVITE|SUBSCRIBE")) {
                $var(sn) = $RAi;
                if ($RAp != 5060) {
                        $var(sn) = $_s($var(sn):$RAp);
                }
                remove_hf("Route");
                record_route_advertised_address("$var(sn)");
        }
        return;
}

failure_route[LOCALFAILURE]{

        if(t_is_expired() || t_any_timeout()){
                if (sql_query("ca","call update_failure_code('$ci',408)","ra") == 1) {
                                ;   #分号必须 #
                }
                sql_result_free("ra");
        }
        exit;

}

#RTPENGINE managent
route[RTPMANA]{
        if($rs != 180) {
                $var(sdp) = $rb;
        }
        if (has_body("application/sdp")) {
                $var(sdp) = $(var(sdp){re.subst,/^s=(.*)/s=AZP Media Server/});
        }
#!ifdef ALERT

        if(is_request()){
                xlog("L_ALERT","-------$rs----------------is_request------begin------$rm-----------------");
                route(NATTEST);
                xlog("L_ALERT","-----------------------is_request------end-----------------------");
       }else{
                xlog("L_ALERT","----------$rs-------------is_reply------begin-------$rm----------------");
                route(NATTEST);
                xlog("L_ALERT","-----------------------is_reply------end-----------------------");
       }
#!endif

        $var(flags) = "trust-address replace-origin codec-transcode-PCMA codec-transcode-PCMU codec-transcode-G729a codec-transcode-G729 replace-session-connection rtcp-mux-demux ICE=remove RTP/AVP";
        if(nat_uac_test(8)){
                $var(flags) = "replace-origin codec-transcode-PCMA codec-transcode-PCMU codec-transcode-G729a codec-transcode-G729 replace-session-connection rtcp-mux-demux ICE=remove RTP/AVP";
        }

#!ifdef WITH_SINGLEMEDIA
        $avp(setid)=1;
        if (sql_query("ca","SELECT setid FROM yyd_rtpengine WHERE yyd_rtpengine.isDefault=1  LIMIT 1","ra") == 1) {
                $avp(setid) = $(dbr(ra=>[0,0]){s.int});
        }
        sql_result_free("ra");
        rtpengine_manage("$var(flags)");
        return;
#!endif
        $var(rtp1)= $(dlg_var(rtp1){s.int});
        $var(rtp2)= $(dlg_var(rtp2){s.int});

        if($var(rtp1)==$var(rtp2)){
                set_rtpengine_set("$var(rtp1)");
        }else{
                set_rtpengine_set("$var(rtp1)","$var(rtp2)");
        }

        if(is_method("INVITE|UPDATE") && has_body("application/sdp")){
                if($rs==183 || $rs==200){
                      rtpengine_answer("$var(flags)");
                } else{
                        rtpengine_offer("$var(flags)");
                }
        }
        if(is_method("ACK") && has_body("application/sdp")){
               rtpengine_answer("$var(flags)");
        }
        if(is_method("BYE|CANCEL")){
                rtpengine_delete();
        }

        return;
}
route[NATTEST]{

        if (has_body("application/sdp"))
                xlog("L_INFO","出现媒体媒体.............................................");
        if (nat_uac_test("1"))
                xlog("L_INFO","TO:$ru 1-在[Contact]标头中搜索RFC1918或RFC6598地址的出现.");
        if (nat_uac_test("2"))
                xlog("L_INFO","TO:$ru 2-使用接收测试：将[Via]标头中的地址与信令的源IP地址进行比较.");
        if (nat_uac_test("4"))
                xlog("L_INFO","TO:$ru 4-搜索最顶部的[Via]以查找RFC1918或RFC6598地址的出现.");
        if (nat_uac_test("8"))
                xlog("L_INFO","TO:$ru 8-在SDP中搜索RFC1918或RFC6598地址的出现.");
        if (nat_uac_test("16"))
                xlog("L_INFO","TO:$ru 16-测试源端口是否与[Via]标头中的端口不同.");
        if (nat_uac_test("32"))
                xlog("L_INFO","TO:$ru 32-测试信令的源IP地址是RFC1918还是RFC6598地址.");
        if (nat_uac_test("64"))
                xlog("L_INFO","TO:$ru 64-测试信令的源连接是否为WebSocket.");
        if (nat_uac_test("128"))
                xlog("L_INFO","TO:$ru 128-测试[Contact]标头URI端口是否与请求的源端口不同.");
        return ;

}